use std::{
    collections::{BTreeMap, BTreeSet},
    path::{Path, PathBuf},
};

use nvim_rs::{compat::tokio::Compat, Neovim};
use regex::Regex;

use crate::{
    connection,
    error::Error,
    plugin::{
        messages::Message,
        note::{Note, PhysicalNote, Tag},
    },
};

// TODO: find a better place for this
macro_rules! nvim_eval_and_cast {
    ($vname:ident, $nvim:expr, $eval:expr, $cast:ident, $error_message:expr) => {
        let $vname = $nvim.eval($eval).await?;
        let $vname = $vname.$cast().ok_or($error_message)?;
    };
}

mod links;
mod markdown;
mod messages;
mod note;

#[derive(Clone)]
pub struct Config {
    home_path: PathBuf,
    note_id_timestamp_format: String,
    date_format: String,
    time_format: String,
}
impl Config {
    pub fn parse_from_args() -> Config {
        let mut args = std::env::args().skip(1);
        let home_path: PathBuf = args.next().expect("first argument should be wiki home path").into();
        if !home_path.is_absolute() {
            panic!("home path should be absolute");
        }
        let c = Config {
            home_path,
            note_id_timestamp_format: args.next().expect("second argument should be note id timestamp format"),
            date_format: args.next().expect("third argument should be date format"),
            time_format: args.next().expect("fourth argument should be time format"),
        };
        assert_eq!(args.next(), None, "there should only be 4 arguments");
        c
    }
}

#[derive(Clone)]
pub struct WikiPlugin {
    pub config: Config,
}

#[async_trait::async_trait]
impl nvim_rs::Handler for WikiPlugin {
    type Writer = Compat<tokio::fs::File>;

    async fn handle_request(
        &self,
        name: String,
        args: Vec<nvim_rs::Value>,
        nvim: Neovim<Compat<tokio::fs::File>>,
    ) -> Result<nvim_rs::Value, nvim_rs::Value> {
        // TODO: this is a hack so that RegenerateAutogeneratedSections can block but ideally there would be 2 message types for both of these functions
        self.handle_notify(name, args, nvim).await;
        Ok(nvim_rs::Value::Nil)
    }

    async fn handle_notify(&self, name: String, args: Vec<nvim_rs::Value>, mut nvim: Neovim<Compat<tokio::fs::File>>) {
        let message = Message::parse(name, args);

        let result = match message {
            Message::NewNote { directory, focus } => self.new_note(&mut nvim, directory, focus).await.map(|_| ()),
            Message::OpenIndex {} => self.open_index(&mut nvim).await,
            Message::DeleteNote {} => self.delete_note(&mut nvim).await,
            Message::NewNoteAndInsertLink {} => self.new_note_and_insert_link(&mut nvim).await,
            Message::OpenTagIndex {} => self.open_tag_index(&mut nvim).await,
            Message::FollowLink {} => self.follow_link(&mut nvim).await,
            Message::InsertLinkAtCursor { link_to_directories, link_to_id, link_text } => {
                // TODO: move this logic somewhere else
                self.insert_link_at_cursor(&mut nvim, &Note::new_physical(link_to_directories, link_to_id), link_text).await
            }
            Message::InsertLinkAtCursorOrCreate { link_to_directories, link_to_id, link_text } => {
                let n;
                let note = match link_to_id {
                    Some(link_to_id) => {
                        n = Note::new_physical(link_to_directories, link_to_id); // TODO: move this logic somewhere else
                        Some(&n)
                    }
                    None => None,
                };

                self.insert_link_at_cursor_or_create(&mut nvim, note, link_text).await
            }
            Message::InsertLinkToPathAtCursorOrCreate { link_to_path, link_text } => {
                self.insert_link_to_path_at_cursor_or_create(&mut nvim, link_to_path, link_text).await
            }

            Message::RegenerateAutogeneratedSections {} => self.regenerate_autogenerated_sections(&mut nvim).await,
            Message::Invalid(e) => Err(e.into()),
        };

        if let Err(e) = result {
            connection::print_error(&mut nvim, e).await;
        }
    }
}

impl WikiPlugin {
    async fn new_note(&self, nvim: &mut Neovim<Compat<tokio::fs::File>>, directories: Vec<String>, focus: bool) -> Result<Note, Error> {
        nvim_eval_and_cast!(title, nvim, r#"input("note name: ")"#, as_str, "vim function input( should always return a string");

        let now = chrono::Local::now();
        let note_id = now.format(&self.config.note_id_timestamp_format).to_string();

        let buf_path = {
            let mut p = self.config.home_path.clone();
            p.extend(&directories);
            p.push(&note_id);
            p.set_extension("md");
            p
        };

        // TODO: customizable templates?
        let buf_contents = [
            "---".to_string(),
            format!("title: {title}"),
            format!("date: {}", now.format(&self.config.date_format)),
            format!("time: {}", now.format(&self.config.time_format)),
            "tags:".to_string(),
            "---".to_string(),
        ]
        .to_vec();

        let buf = nvim.create_buf(true, false).await?;
        buf.set_name(buf_path.to_str().ok_or_else(|| format!("invalid buf path {buf_path:?}"))?).await?;
        buf.set_lines(0, 0, true, buf_contents).await?;
        buf.set_option("filetype", "wikipluginnote".into()).await?;

        if focus {
            nvim.set_current_buf(&buf).await?;
        }

        Ok(Note::new_physical(directories, note_id))
    }

    async fn open_index(&self, nvim: &mut Neovim<Compat<tokio::fs::File>>) -> Result<(), Error> {
        let index_path = self.config.home_path.join("index.md");
        let index_path: &str = index_path.to_str().ok_or_else(|| format!("invalid note index path {index_path:?}"))?;
        nvim.cmd(vec![("cmd".into(), "edit".into()), ("args".into(), vec![nvim_rs::Value::from(index_path)].into())], vec![]).await?;

        Ok(())
    }

    async fn new_note_and_insert_link(&self, nvim: &mut Neovim<Compat<tokio::fs::File>>) -> Result<(), Error> {
        let new_note = self.new_note(nvim, Vec::new(), false).await?;
        self.insert_link_at_cursor(nvim, &new_note, None).await?;
        Ok(())
    }

    async fn insert_link_to_path_at_cursor_or_create(
        &self,
        nvim: &mut Neovim<Compat<tokio::fs::File>>,
        link_to: Option<String>,
        link_text: Option<String>,
    ) -> Result<(), Error> {
        let n;
        let note = match link_to {
            Some(link_to_path) => {
                let path = Path::new(&link_to_path);
                n = Note::Physical(PhysicalNote::parse_from_filepath(&self.config, path)?);
                Some(&n)
            }
            None => None,
        };

        self.insert_link_at_cursor_or_create(nvim, note, link_text).await?;

        Ok(())
    }

    async fn insert_link_at_cursor_or_create(
        &self,
        nvim: &mut Neovim<Compat<tokio::fs::File>>,
        link_to: Option<&Note>,
        link_text: Option<String>,
    ) -> Result<(), Error> {
        let note = match link_to {
            Some(link_to) => link_to,
            None => &self.new_note(nvim, Vec::new(), false).await?,
        };
        self.insert_link_at_cursor(nvim, note, link_text).await?;
        Ok(())
    }

    async fn insert_link_at_cursor(
        &self,
        nvim: &mut Neovim<Compat<tokio::fs::File>>,
        link_to: &Note,
        link_text: Option<String>,
    ) -> Result<(), Error> {
        match link_to {
            Note::Physical(link_to) => {
                let link_text = match link_text {
                    Some(lt) => lt,
                    None => {
                        markdown::get_title(&markdown::parse_frontmatter(&link_to.parse_markdown(&self.config, nvim).await?)?).unwrap_or_default()
                    }
                };

                let current_note = Note::get_current_note(&self.config, nvim).await?;
                let link_path_text = links::format_link(&self.config, &current_note, &link_to.path(&self.config))?;
                nvim.put(vec![format!("[{link_text}]({link_path_text})")], "c", false, true).await?;

                Ok(())
            }
            Note::Scratch(_) => Err("cannot link to scratch note")?,
        }
    }

    async fn open_tag_index(&self, nvim: &mut Neovim<Compat<tokio::fs::File>>) -> Result<(), Error> {
        let notes = self.list_all_physical_notes()?;
        let mut tag_table: BTreeMap<Tag, Vec<(&PhysicalNote, String, PathBuf)>> = BTreeMap::new(); // TODO: eventually this should become &(Note, String, PathBuf)
        let mut tag_list = BTreeSet::new();

        for note in &notes {
            let frontmatter = markdown::parse_frontmatter(&note.parse_markdown(&self.config, nvim).await?)?;
            let title = markdown::get_title(&frontmatter)?;
            let tags = markdown::get_tags(&frontmatter).unwrap_or_default();
            let path = note.path(&self.config);

            for tag in tags {
                tag_table.entry(tag.clone()).or_default().push((note, title.clone(), path.clone()));
                tag_list.insert(tag);
            }
        }

        let buffer = nvim.create_buf(true, true).await?;
        buffer.set_option("filetype", "wikipluginnote".into()).await?;

        for tag in tag_list {
            buffer.set_lines(-2, -2, false, vec![format!("# {}", tag), "".to_string()]).await?;

            for (_, note_title, note_path) in &tag_table[&tag] {
                buffer
                    .set_lines(-2, -2, false, vec![format!("- [{}]({})", note_title, note_path.to_str().ok_or("PathBuf contains invalid unicode")?)])
                    .await?;
            }

            buffer.set_lines(-2, -2, false, vec!["".to_string()]).await?;
        }

        nvim.set_current_buf(&buffer).await?;

        Ok(())
    }

    async fn follow_link(&self, nvim: &mut Neovim<Compat<tokio::fs::File>>) -> Result<(), Error> {
        let current_note = Note::get_current_note(&self.config, nvim).await?;
        let current_md = current_note.parse_markdown(&self.config, nvim).await?;

        nvim_eval_and_cast!(cursor_byte_index, nvim, r#"line2byte(line(".")) + col(".") - 1 - 1"#, as_u64, "byte index should be a number");
        let (_, link_path) = markdown::rec_find_preorder(&current_md, &mut |node| match node {
            ::markdown::mdast::Node::Link(::markdown::mdast::Link { children: _, position: Some(position), url, title: _ }) => {
                if markdown::point_in_position(position, cursor_byte_index.try_into().expect("byte index u64 does not fit into usize")) {
                    Some(url.to_string())
                } else {
                    None
                }
            }
            _ => None,
        })
        .ok_or("not on a link")?;

        let new_note_path = links::resolve_link(&self.config, &current_note, &link_path)?;

        nvim.cmd(
            vec![
                ("cmd".into(), "edit".into()),
                ("args".into(), vec![nvim_rs::Value::from(new_note_path.to_str().ok_or("pathbuf cannot be converted to string")?)].into()),
            ],
            vec![],
        )
        .await?;

        Ok(())
    }

    async fn delete_note(&self, nvim: &mut Neovim<Compat<tokio::fs::File>>) -> Result<(), Error> {
        nvim_eval_and_cast!(current_buf_path_str, nvim, r#"expand("%:p")"#, as_str, "vim function expand( should always return a string");
        let current_buf_path = Path::new(current_buf_path_str);

        nvim_eval_and_cast!(
            choice,
            nvim,
            r#"input("are you sure you want to delete this note?\noptions: 'yes' for yes, anything else for no\ninput: ")"#,
            as_str,
            "vim function input( should always return a string"
        );
        if choice == "yes" {
            std::fs::remove_file(current_buf_path)?;
            nvim.command(&format!(r#"echo "\n{} deleted""#, current_buf_path.to_str().ok_or("current buffer path should be utf8")?)).await?;
        } else {
            nvim.command(r#"echo "\nnot deleting""#).await?;
        }
        Ok(())
    }

    async fn regenerate_autogenerated_sections(&self, nvim: &mut Neovim<Compat<tokio::fs::File>>) -> Result<(), Error> {
        let current_note = Note::get_current_note(&self.config, nvim).await?;
        let current_buf = nvim.get_current_buf().await?;

        let autogen_start_marker_regex =
            Regex::new(r#"\<wikiplugin_autogenerate\>\s*(\w+)(.*)"#).expect("autogenerate start marker regex should be valid");
        let autogen_end_marker_regex = Regex::new(r#"\<wikiplugin_autogenerate_end\>"#).expect("autogenerate end marker regex should be valid");

        let mut match_index = 0;
        loop {
            let buf_lines = current_buf.get_lines(0, -1, false).await?;

            let start_line = buf_lines
                .iter()
                .enumerate()
                .filter_map(|(line_number, line)| Some((line_number, autogen_start_marker_regex.captures(line)?)))
                .nth(match_index);
            let (start_line_nr, start_line_match) = match start_line {
                Some(start_line) => start_line,
                None => break,
            };

            let end_line = {
                let end_marker_line = buf_lines
                    .iter()
                    .enumerate()
                    .skip(start_line_nr + 1)
                    .find(|(_, line)| autogen_end_marker_regex.is_match(line))
                    .map(|(line_number, _)| line_number);
                let next_start_line = buf_lines
                    .iter()
                    .enumerate()
                    .skip(start_line_nr + 1)
                    .find(|(_, line)| autogen_start_marker_regex.is_match(line))
                    .map(|(line_number, _)| line_number);

                let insert_end_line = || async {
                    current_buf
                        .set_lines(
                            (start_line_nr + 1).try_into()?,
                            (start_line_nr + 1).try_into()?,
                            false,
                            vec!["wikiplugin_autogenerate_end".to_string()],
                        )
                        .await?;
                    Ok::<_, Error>(start_line_nr + 1)
                };

                match (end_marker_line, next_start_line) {
                    (None, _) => {
                        // if there is no end marker line, we insert an end marker line immediately after
                        insert_end_line().await?
                    }
                    (Some(end_marker_line), None) => {
                        // if there is an end marker line and no later start marker line, we replace until the end marker line
                        end_marker_line
                    }
                    (Some(end_marker_line), Some(next_start_line)) => {
                        // if there is both, it depends on which line comes first
                        if end_marker_line < next_start_line {
                            end_marker_line
                        } else {
                            // if the next start line comes first, then the end marker line actually applies to the next autogenerated section,
                            // so we have to insert an end marker line
                            insert_end_line().await?
                        }
                    }
                }
            };

            let autogenerate_command = start_line_match
                .get(1)
                .ok_or("autogeneration is missing command name (this should never happen because the regex always contains this capturing group)")?
                .as_str();
            let autogenerate_arguments = start_line_match
                .get(2)
                .expect("autogeneration start marker should have second capturing group")
                .as_str()
                .split(";")
                .map(str::trim)
                .collect::<Vec<_>>();

            // TODO: full blown dsl with filters and pipes and things here?
            let replacement = match autogenerate_command {
                "index" => {
                    let directory: Vec<_> = autogenerate_arguments.first().copied().unwrap_or("").split("/").collect();
                    let sort_by = autogenerate_arguments.get(1).copied().unwrap_or("title");

                    let mut files = Vec::new();
                    for file in self.list_all_physical_notes()? {
                        if file.directories == directory {
                            let md = file.parse_markdown(&self.config, nvim).await?;
                            let frontmatter = markdown::parse_frontmatter(&md)?;
                            // TODO: having to do all of this is pretty messy but it is needed because the comparator cannot be async
                            let title = markdown::get_title(&frontmatter).ok();
                            let timestamp = markdown::get_timestamp(&frontmatter, &self.config)?;
                            files.push((file, title, timestamp))
                        }
                    }

                    let comparator = match sort_by {
                        "title" => |a: &(PhysicalNote, Option<String>, chrono::NaiveDateTime),
                                    b: &(PhysicalNote, Option<String>, chrono::NaiveDateTime)| {
                            if a.1.is_none() || b.1.is_none() {
                                a.0.id.cmp(&b.0.id)
                            } else {
                                a.1.cmp(&b.1)
                            }
                        },
                        "date" => |a: &(PhysicalNote, Option<String>, chrono::NaiveDateTime),
                                   b: &(PhysicalNote, Option<String>, chrono::NaiveDateTime)| { a.2.cmp(&b.2) },
                        "id" => |a: &(PhysicalNote, Option<String>, chrono::NaiveDateTime),
                                 b: &(PhysicalNote, Option<String>, chrono::NaiveDateTime)| { a.0.id.cmp(&b.0.id) },
                        _ => {
                            nvim.err_writeln(&format!("error: invalid comparison '{}'", sort_by)).await?;
                            |a: &(PhysicalNote, Option<String>, chrono::NaiveDateTime), b: &(PhysicalNote, Option<String>, chrono::NaiveDateTime)| {
                                a.0.id.cmp(&b.0.id)
                            }
                        }
                    };
                    files.sort_by(comparator);

                    let mut result = Vec::new();
                    for file in files {
                        let link_path = links::format_link(&self.config, &current_note, &file.0.path(&self.config))?;
                        result.push(format!("- [{}]({})", file.1.unwrap_or("".to_string()), link_path));
                    }

                    Some(result)
                }

                "backlinks" => {
                    /*
                    local result = {}

                    for _, filename in ipairs(list_all_files()) do
                        local file_contents = vim.fn.readfile(filename)
                        local _, note_contents = split_lines_into_frontmatter_and_content(file_contents)
                        local note_title = scan_note_title(file_contents)

                        for _, link in ipairs(scan_for_links(note_contents)) do
                            local link_text = link[1]
                            local link_path = link[2]
                            local linked_file_path = find_link_file(filename, link_path)
                            if linked_file_path == Path:new(current_buf_filename):absolute() then
                                table.insert(result, "- [" .. (note_title or "") .. "](" .. Path:new(filename):make_relative(current_buf_parent_dir) .. ")")
                                break
                            end
                        end

                    end

                    return result
                        */
                    nvim.err_writeln("backlinks autogeneration has not been implemented yet").await?;
                    Some(vec![])
                }

                _ => {
                    nvim.err_writeln(&format!("error: invalid autogenerate function '{}'", autogenerate_command)).await?;
                    None
                }
            };

            if let Some(replacement) = replacement {
                current_buf.set_lines((start_line_nr + 1).try_into()?, end_line.try_into()?, false, replacement).await?;
            }

            match_index += 1;
        }

        Ok(())
    }

    fn list_all_physical_notes(&self) -> Result<Vec<PhysicalNote>, Error> {
        glob::glob(&format!("{}/**/*.md", self.config.home_path.to_str().ok_or("wiki home path should always be valid unicode")?))?
            .map(|path| match path {
                Ok(path) => {
                    let path = path.as_path();
                    PhysicalNote::parse_from_filepath(&self.config, path)
                }
                Err(e) => Err(e)?,
            })
            .collect::<Result<Vec<_>, _>>()
    }
}
