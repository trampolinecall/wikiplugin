#[derive(Debug)]
pub enum MessageParseError {
    WrongArgumentType { argument_name: &'static str, message_name: &'static str, expected_type: String, actual_value: nvim_rs::Value },
    UnknownMessage { message_enum_name: &'static str, message: String, args: Vec<nvim_rs::Value> },
}

impl std::fmt::Display for MessageParseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            MessageParseError::WrongArgumentType { argument_name, message_name, expected_type, actual_value } => {
                write!(
                    f,
                    "actual argument {:?} to argument '{}' message '{}' is not of expected type '{}'",
                    actual_value, argument_name, message_name, expected_type
                )
            }
            MessageParseError::UnknownMessage { message_enum_name, message, args } => {
                write!(f, "invalid message '{}' with args {:?} for message type {}", message, args, message_enum_name)
            }
        }
    }
}
impl std::error::Error for MessageParseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        todo!()
    }
}

trait FromNvimValue: Sized {
    fn from(message_name: &'static str, argument_name: &'static str, v: nvim_rs::Value) -> Result<Self, MessageParseError> {
        match Self::convert(&v) {
            Some(converted) => Ok(converted),
            None => {
                Err(MessageParseError::WrongArgumentType { argument_name, message_name, expected_type: Self::type_description(), actual_value: v })
            }
        }
    }
    fn convert(v: &nvim_rs::Value) -> Option<Self>;
    fn type_description() -> String;
}

impl<T: FromNvimValue> FromNvimValue for Vec<T> {
    fn convert(v: &nvim_rs::Value) -> Option<Self> {
        v.as_array()?.iter().map(|v| T::convert(v)).collect::<Option<Vec<_>>>()
    }

    fn type_description() -> String {
        format!("array of {}", T::type_description())
    }
}
impl<T: FromNvimValue> FromNvimValue for Option<T> {
    fn convert(v: &nvim_rs::Value) -> Option<Self> {
        if v.is_nil() {
            Some(None)
        } else {
            T::convert(v).map(Some)
        }
    }

    fn type_description() -> String {
        format!("{} or nil", T::type_description())
    }
}
impl FromNvimValue for bool {
    fn convert(v: &nvim_rs::Value) -> Option<bool> {
        v.as_bool()
    }
    fn type_description() -> String {
        "a bool".to_string()
    }
}
impl FromNvimValue for String {
    fn convert(v: &nvim_rs::Value) -> Option<String> {
        v.as_str().map(|s| s.to_string())
    }
    fn type_description() -> String {
        "a string".to_string()
    }
}

macro_rules! messages {
    ($vis:vis enum $message_enum_name:ident { $($message_name_pascal:ident, $message_name_snake:ident, { $($field_name:ident: $field_ty:ty),* $(,)? }),* $(,)? }) => {
        $vis enum $message_enum_name {
            $(
                $message_name_pascal { $($field_name: $field_ty),* },
            )+
            Invalid($crate::plugin::messages::MessageParseError),
        }

        impl $message_enum_name {
            #[inline]
            pub fn parse(message: String, args: Vec<nvim_rs::Value>) -> $message_enum_name {
                match &*message {
                    $(
                        stringify!($message_name_snake) => {
                            #[allow(unused_mut, unused_variables)]
                            let mut arg_iter = args.into_iter().chain(std::iter::repeat(nvim_rs::Value::Nil));

                            #[allow(clippy::redundant_closure_call)]
                            let result = (|| {
                                $(
                                    let $field_name = <$field_ty as FromNvimValue>::from(stringify!($message_name_snake), stringify!($field_name), arg_iter.next().expect("infinite iterator should always have next value"))?;
                                )*

                                Ok::<_, $crate::plugin::messages::MessageParseError>($message_enum_name::$message_name_pascal { $( $field_name ),* })
                            })();

                            match result {
                                Ok(res) => res,
                                Err(err) => $message_enum_name::Invalid(err),
                            }
                        }
                    )+
                    _ => $message_enum_name::Invalid($crate::plugin::messages::MessageParseError::UnknownMessage { message_enum_name: stringify!($message_enum_name), message, args }),
                }
            }
        }
    };
}

messages! {
    pub enum RequestMessage {
        RegenerateAutogeneratedSections, regenerate_autogenerated_sections, {},
    }
}
messages! {
    pub enum NotifyMessage {
        NewNote, new_note, { directory: Vec<String>, focus: bool },
        OpenIndex, open_index, {}, // TODO: configurable index file name?
        DeleteNote, delete_note, {},
        NewNoteAndInsertLink, new_note_and_insert_link, {},
        OpenTagIndex, open_tag_index, {},
        FollowLink, follow_link, {},
        InsertLinkAtCursor, insert_link_at_cursor, { link_to_directories: Vec<String>, link_to_id: String, link_text: Option<String> },
        InsertLinkAtCursorOrCreate, insert_link_at_cursor_or_create, { link_to_directories: Vec<String>, link_to_id: Option<String>, link_text: Option<String> },
        InsertLinkToPathAtCursorOrCreate, insert_link_to_path_at_cursor_or_create, { link_to_path: Option<String>, link_text: Option<String> },
    }
}
